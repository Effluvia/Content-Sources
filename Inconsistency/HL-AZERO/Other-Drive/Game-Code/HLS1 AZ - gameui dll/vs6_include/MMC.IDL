import "oaidl.idl";


///////////////////////////////////////////////////////////////////////////////
/// Interfaces implement by the Common Console's Node Manager

interface IConsole;
interface IHeaderCtrl;
interface IToolbar;
interface IImageList;
interface IResultData;
interface IConsoleNameSpace;
interface IPropertySheetProvider;
interface IPropertySheetCallback;
interface IContextMenuProvider;
interface IContextMenuCallback;
interface IControlbar;
interface IConsoleVerb;
interface IMenuButton;
interface IQuickFilter;


///////////////////////////////////////////////////////////////////////////////
/// Interfaces implement by the Snap-in server

interface IComponent;
interface IComponentData;
interface IExtendPropertySheet;
interface IExtendContextMenu;
interface IExtendControlbar;
interface IResultDataCompare;
interface ISnapinAbout;
interface IResultOwnerData;

///////////////////////////////////////////////////////////////////////////////
/// Type definitions

typedef IConsole*                   LPCONSOLE;
typedef IHeaderCtrl*                LPHEADERCTRL;
typedef IToolbar*                   LPTOOLBAR;
typedef IImageList*                 LPIMAGELIST;
typedef IResultData*                LPRESULTDATA;
typedef IConsoleNameSpace*          LPCONSOLENAMESPACE;
typedef IPropertySheetProvider*     LPPROPERTYSHEETPROVIDER;
typedef IPropertySheetCallback*     LPPROPERTYSHEETCALLBACK;
typedef IContextMenuProvider*       LPCONTEXTMENUPROVIDER;
typedef IContextMenuCallback*       LPCONTEXTMENUCALLBACK;
typedef IControlbar*                LPCONTROLBAR;
typedef IConsoleVerb*               LPCONSOLEVERB;
typedef IMenuButton*                LPMENUBUTTON;
typedef IQuickFilter*               LPQUICKFILTER;

typedef IComponent*                 LPCOMPONENT;
typedef IComponentData*             LPCOMPONENTDATA;
typedef IExtendPropertySheet*       LPEXTENDPROPERTYSHEET;
typedef IExtendContextMenu*         LPEXTENDCONTEXTMENU;
typedef IExtendControlbar*          LPEXTENDCONTROLBAR;
typedef IResultDataCompare*         LPRESULTDATACOMPARE;
typedef ISnapinAbout*               LPSNAPABOUT;
typedef IResultOwnerData*           LPRESULTOWNERDATA;

///////////////////////////////////////////////////////////////////////////////
// Published Common Console ListView constants

#define LVS_ICON                0x0000
#define LVS_REPORT              0x0001
#define LVS_SMALLICON           0x0002
#define LVS_LIST                0x0003
#define LVSICF_NOINVALIDATEALL  0x00000001
#define LVSICF_NOSCROLL         0x00000002

const long  MMCLV_AUTO = -1;
const long  MMCLV_NOPARAM = -2;
const long  MMCLV_NOICON = -1;
const long  MMCLV_VIEWSTYLE_ICON = LVS_ICON;
const long  MMCLV_VIEWSTYLE_SMALLICON = LVS_SMALLICON;
const long  MMCLV_VIEWSTYLE_LIST = LVS_LIST;
const long  MMCLV_VIEWSTYLE_REPORT = LVS_REPORT;
const long  MMCLV_VIEWSTYLE_FILTERED = 0x0004;
const void* MMCLV_NOPTR = 0x0;
const long  MMCLV_UPDATE_NOINVALIDATEALL = LVSICF_NOINVALIDATEALL;
const long  MMCLV_UPDATE_NOSCROLL = LVSICF_NOSCROLL;

static unsigned short* MMC_CALLBACK = ((unsigned short *)(-1));

///////////////////////////////////////////////////////////////////////////////
// ResultData and Scope Data item structures.

typedef long    HSCOPEITEM;
typedef long    COMPONENTID;
typedef long    HRESULTITEM;

const DWORD RDI_STR     = 0x0002;
const DWORD RDI_IMAGE   = 0x0004;
const DWORD RDI_STATE   = 0x0008;
const DWORD RDI_PARAM   = 0x0010;
const DWORD RDI_INDEX   = 0x0020;
const DWORD RDI_INDENT  = 0x0040;


typedef enum _MMC_RESULT_VIEW_STYLE
{
    MMC_SINGLESEL       = 0x0001,
    MMC_SHOWSELALWAYS   = 0x0002,
    MMC_NOSORTHEADER    = 0x0004

} MMC_RESULT_VIEW_STYLE;


// List view with single select
const long MMC_VIEW_OPTIONS_NONE            = 0x0000;

// NO List view. Only custom views.
const long MMC_VIEW_OPTIONS_NOLISTVIEWS     = 0x0001;

// List view with multi select.
const long MMC_VIEW_OPTIONS_MULTISELECT     = 0x0002;
 
//List view with user owned data
const long MMC_VIEW_OPTIONS_OWNERDATALIST   = 0x0004;

//List view with filtering allowed
const long MMC_VIEW_OPTIONS_FILTERED        = 0x0008;

// Create new control (don't use cached)
const long MMC_VIEW_OPTIONS_CREATENEW       = 0x0010;

// Property sheet options
const DWORD MMC_PSO_NOAPPLYNOW              = 0x00000001;
const DWORD MMC_PSO_HASHELP                 = 0x00000002;
const DWORD MMC_PSO_NEWWIZARDTYPE           = 0x00000004;

 

// Type of controls that can be attached to the IControlbar
typedef enum  _MMC_CONTROL_TYPE
{
    TOOLBAR,
    MENUBUTTON,
    COMBOBOXBAR
} MMC_CONTROL_TYPE;


///////////////////////////////////////////////////////////////////////////////
// Console commands - These should be reviewed
//
typedef enum _MMC_CONSOLE_VERB
{
    MMC_VERB_NONE            = 0x0000,
    MMC_VERB_OPEN            = 0x8000,
    MMC_VERB_COPY            = 0x8001, 
    MMC_VERB_PASTE           = 0x8002, 
    MMC_VERB_DELETE          = 0x8003, 
    MMC_VERB_PROPERTIES      = 0x8004, 
    MMC_VERB_RENAME          = 0x8005, 
    MMC_VERB_REFRESH         = 0x8006,      
    MMC_VERB_PRINT           = 0x8007, 
    
} MMC_CONSOLE_VERB;

// Structure to create buttons on the toolbar
typedef struct _MMCButton
{
    int      nBitmap;       // Offset into the bitmap list 
    int      idCommand;     // Command ID return when the button is clicked
    BYTE     fsState;       // TBSTYLE_ENABLED ..etc
    BYTE     fsType;        // TBSTYLE_BUTTON || TBSTYLE_SEP
    LPOLESTR     lpButtonText;  // Text value for the Button
    LPOLESTR     lpTooltipText; // Text value for the tooltip
    
} MMCBUTTON;

typedef MMCBUTTON* LPMMCBUTTON;

typedef enum _MMC_BUTTON_STATE
{
    ENABLED         = 0x01,
    CHECKED         = 0x02,
    HIDDEN          = 0x04,
    INDETERMINATE   = 0x08,
    BUTTONPRESSED   = 0x10,

} MMC_BUTTON_STATE;

typedef struct _RESULTDATAITEM
{
    DWORD       mask;
    BOOL        bScopeItem;
    HRESULTITEM itemID;
    int         nIndex;
    int         nCol;
    LPOLESTR    str;
    int         nImage;
    UINT        nState;
    LPARAM      lParam;
    int         iIndent;
} RESULTDATAITEM;

typedef RESULTDATAITEM* LPRESULTDATAITEM;

// Find result item options   
const DWORD RFI_PARTIAL = 0x0001;
const DWORD RFI_WRAP    = 0x0002;

typedef struct _RESULTFINDINFO
{
    LPOLESTR    psz;
    int         nStart;
    DWORD       dwOptions;
}
 RESULTFINDINFO;
typedef RESULTFINDINFO* LPRESULTFINDINFO;

//
// Sort Result Items options
//
const DWORD RSI_DESCENDING = 0x0001;


const DWORD SDI_STR         = 0x00002;
const DWORD SDI_IMAGE       = 0x00004;
const DWORD SDI_OPENIMAGE   = 0x00008;
const DWORD SDI_STATE       = 0x00010;
const DWORD SDI_PARAM       = 0x00020;
const DWORD SDI_CHILDREN    = 0x00040;

// The top 4 bit of the mask determines the relative position of this item,
// relative to the SCOPEDATAITEM::relativeID. By default it is the parent.

// For SDI_PARENT, SCOPEDATAITEM::relativeID is the HSCOPEITEM of the parent.
// As you can see by the SDI_PARENT value it is a no-op. Since by default
// SCOPEDATAITEM::relativeID is treated as the parents ID.
const DWORD SDI_PARENT      = 0x00000000;

// For SDI_PREVIOUS, SCOPEDATAITEM::relativeID is the HSCOPEITEM of the previous sibling
const DWORD SDI_PREVIOUS    = 0x10000000;

// For SDI_NEXT, SCOPEDATAITEM::relativeID is the HSCOPEITEM of the next sibling.
const DWORD SDI_NEXT        = 0x20000000;

// For SDI_PARENT, bit 27 determines whether the item is to be inserted as the
// first child. By default this item will inserted as the last child.
const DWORD SDI_FIRST       = 0x08000000;


typedef struct _SCOPEDATAITEM
{
    DWORD       mask;
    LPOLESTR    displayname;
    int         nImage;
    int         nOpenImage;
    UINT        nState;
    int         cChildren;
    LPARAM      lParam;
    HSCOPEITEM  relativeID;
    HSCOPEITEM  ID;
} SCOPEDATAITEM;

typedef SCOPEDATAITEM* LPSCOPEDATAITEM;

typedef enum _MMC_SCOPE_ITEM_STATE
{
    MMC_SCOPE_ITEM_STATE_NORMAL = 0x0001,        // Not bold. To set or get.
    MMC_SCOPE_ITEM_STATE_BOLD = 0x0002,          // To set or get.
    MMC_SCOPE_ITEM_STATE_EXPANDEDONCE = 0x0003,  // Only to get.
    
} MMC_SCOPE_ITEM_STATE;


typedef struct _CONTEXTMENUITEM
{
    LPWSTR      strName;
    LPWSTR      strStatusBarText;
    LONG        lCommandID;
    LONG        lInsertionPointID;
    LONG        fFlags;
    LONG        fSpecialFlags;
} CONTEXTMENUITEM;

typedef CONTEXTMENUITEM* LPCONTEXTMENUITEM;

//
// Console defined menu command IDs
//   The console reserves the negative numbers for predefined menu command
//   IDs which it sends to a snapin's IExtendContextMenu::Command method  
//
typedef enum _MMC_MENU_COMMAND_IDS
{
    MMCC_STANDARD_VIEW_SELECT = -1
} MMC_MENU_COMMAND_IDS;



//IMenuButton data structure

typedef struct _MENUBUTTONDATA
{
    int      idCommand;
    int      x;
    int      y;
} MENUBUTTONDATA;

typedef MENUBUTTONDATA* LPMENUBUTTONDATA;


//  For multi select the cookie passed to the snapins will be 
//  MMC_MULTI_SELECT_COOKIE. The data object that will be returned 
//  should provide the CCF_OBJECT_TYPES_IN_MULTI_SELECT clipboard
//  format.
// 
const long MMC_MULTI_SELECT_COOKIE = -2;

// Special cookie value for requesting window properties data object
const long MMC_WINDOW_COOKIE = -3;

//IQuickFilter data structure

// Published filter constants
#define FILTER_TYPE_STRING  1
#define FILTER_TYPE_INT     3

typedef enum _MMC_FILTER_TYPE
{
    MMC_STRING_FILTER = FILTER_TYPE_STRING,
    MMC_INT_FILTER =    FILTER_TYPE_INT
} MMC_FILTER_TYPE;
         
typedef struct _FILTERDATA
{
    DWORD       dwFlags;	    // reserved (should be zero)
    DWORD       dwType;		    // one of the FILTER_TYPE_<bla> values
    INT         iFilter;		// filter value if int type filter
    LPOLESTR   pszFilter;    	// filter value, if string filter
    INT         cchFilter;		// max size of string filter value
} FILTERDATA, *LPFILTERDATA;

typedef enum _MMC_FILTER_CHANGE_CODE
{
    MFCC_DISABLE      = 0,
    MFCC_ENABLE       = 1,
    MFCC_VALUE_CHANGE = 2
} MMC_FILTER_CHANGE_CODE;
 
/*
NOTIFICATIONS
=============

Notify(dataobject, event, arg, param);
    For all the MMC_NOTIFY_TYPE events, 
    dataobject
        For single select:
            dataobject for cookie, can be NULL when dataobject is not required
        For multi select:
            Console supplied data object. Supports only one format (CCF_MULTI_SELECT_SNAPIN),
            which can be used to accquire an IUnknow to the primary snapin.
    event = one of the MMCN_NOTIFY_TYPEs
    arg and param depend on type, see below.
    
MMCN_ACTIVATE
    Is sent when a window is being activated or deactivated.
    arg = TRUE if window is activated, false otherwise.
    param = Not used.

MMCN_ADD_IMAGES
    Sent to IComponent to add images for the result pane. The primary snapin
        should add images for both folders and leaf items. Extension snapins
        should add only folder images. 
    arg = ptr to result panes IImageList.
    param = HSCOPEITEM of selected/deselected item
    
MMCN_BTN_CLICK      
    This message is sent when a user clicks on a button.
    arg   = When sent to ExtendControlbar it is the data object of currently selected,
            when sent to IComponent/IComponentData it is 0.
    param = CmdID of the button equal to a value of the MMC_COMMANDS enum type.

MMCN_EXPAND         
    arg = TRUE => expand, FALSE => contract
    param = parents HSCOPEITEM.
    
MMCN_MINIMIZED      
    Is sent when a window is being minimized or maximized.
    arg = TRUE if minimized, false otherwise.
    
MMCN_PROPERTY_CHANGE
    lpDataObject = NULL
    lParam = user object

MMCN_REMOVE_CHILDREN
    Informs the snapin to delete all the cookies it has added below.
    arg = HSCOPEITEM of the node whose children needs to be deleted.
    param = unused.
    return = unused.
    
MMCN_RENAME       
    This gets called the first time to query for rename and a
    second time to do the rename.  For the query S_OK or S_FALSE for the
    return type.  After the rename, we will send the new name with a LPOLESTR.
    arg = 0 for query, 1 for rename action 
    param = LPOLESTR for containing new name   
    return = S_OK to allow rename and S_FALSE to disallow rename.                    

MMCN_SELECT
    If sent to IComponent::Notify:
        arg:
            BOOL bScope = (BOOL) LOWORD(arg);
            BOOL bSelect = (BOOL) HIWORD(arg);
                bScope:     TRUE if an item the scope pane is selected, 
                            FALSE if an item in the result pane is selected.
                bSelect:    TRUE if the item is selected, 
                            FALSE if it is de-selected.
        param: 
            Ignored.                
                
    If sent to IExtendControlbar::ControlbarNotify:
        arg:
            BOOL bScope = (BOOL) LOWORD(arg);
            BOOL bSelect = (BOOL) HIWORD(arg);
                bScope:     TRUE if an item the scope pane is selected, 
                            FALSE if an item in the result pane is selected.
                bSelect:    TRUE if the item is selected,
                            FALSE if it is de-selected.  
        param:
            LPDATAOBJECT pDataobject = (LPDATAOBJECT)param;
            pDataobject data object of item getting selected/de-selected.

    
MMCN_SHOW           
    arg = <>0 if selecting, 0 if deselecting
    param = HSCOPEITEM of selected/deselected item

MMCN_VIEW_CHANGE    
    This message is sent to update all views of a change.
    arg = TRUE if Scope Item, FALSE if Result Item
    param = ptr to DataObject selected

MMCN_MENU_BTNCLICK      
    This message is sent when a user clicks on a button.
    arg   = Data object of currently selected.
    param = Structure (LPMENUBUTTONDATA).

MMCN_SNAPINHELP
    This message is sent when the user requests help about the snapin.
    dataObject = NULL
    arg = 0
    param = 0

MMCN_CONTEXTHELP
    This message is sent when the user requests help about a selected item
    arg = 0
    param = 0 

MMCN_DESELECT_ALL
    This message is sent when all items of an owner-data result pane
    are deselected.
    dataObject = NULL
    arg = 0
    param = 0
    
MMCN_COLUMN_CLICK
    This message is sent when the user clicks on a result listview column header.
    dataObject = NULL
    arg = Column number
    param = Sort option flags (RSI_xxx) 
    
MMCN_DELETE:
    Sent to inform the snapin that the item needs to be deleted. As a result of
    the user hitting the 'Delete' key or delete button.
    dataobject: dataobject of the selected item(s) provided by the snap-in.
    arg, param: unused.

MMCN_CUTORMOVE:
    dataobject: NULL.
    arg: pointer to a dataobject. See multi-selection below.
    param: unused.

MMCN_QUERY_PASTE:
    dataobject: dataobject of the selected item provided by the snap-in.        
    arg: dataobject of the item(s) provided by the source snap-in that needs to be pasted.
    param: unused.
    Return S_OK if the data can be pasted, S_FALSE otherwise.

MMCN_PASTE:
    dataobject & arg: are same as for MMCN_QUERY_PASTE.
    param:
        NULL for move (as opposed to cut).
        For single item paste:
            BOOL* pPasted = (BOOL*)param; 
            Set this to TRUE here if the item was successfully pasted.
        For multi-item paste:
            LPDATAOBJECT* ppDataObj = (LPDATAOBJECT*)param;
            Use this to return a pointer to a dataobject consisting of the 
            items successfully pasted. (see MMCN_CUTORMOVE below).

MMCN_FILTER_STATE:
    This message is sent when the user turns result view filtering on or off.
    dataobject = NULL
    arg = BOOL, True if filter turned on, Flase if filter turned off
    param = unused
     
MMCN_FILTER_CHANGE:
    This message is sent when the filter value for a result view column has been changed. 
    dataobject= NULL
    arg = Filter change code (see MMC_FILTER_CHANGE_CODE enumeration)
    param = column number of changed value, if change code is MFCC_VALUE_CHANGE

MMCN_GET_FILTER_MENU:
    This message is sent to get the filter operators menu for a result view column.
    dataobject = NULL
    arg = Column number
    param = Pointer to returned menu handle (HMENU)
    
MMCN_FILTER_OPERATOR:
    This message is sent when the user selects an entry from a filter operator menu.
    dataobject = NULL
    arg = Column number
    param = Menu item ID  

MMCN_INITOCX:
    Sent to a snap-in when its custom OCX is initialized for the first time.
*/

typedef enum _MMC_NOTIFY_TYPE
{
    MMCN_ACTIVATE           = 0x8001,
    MMCN_ADD_IMAGES         = 0x8002,
    MMCN_BTN_CLICK          = 0x8003,
    MMCN_CLICK              = 0x8004,
    MMCN_COLUMN_CLICK       = 0x8005,
    MMCN_CONTEXTMENU        = 0x8006,   // NOT USED
    MMCN_CUTORMOVE          = 0x8007,
    MMCN_DBLCLICK           = 0x8008,
    MMCN_DELETE             = 0x8009,
    MMCN_DESELECT_ALL       = 0x800A,
    MMCN_EXPAND             = 0x800B,
    MMCN_HELP               = 0x800C,   // NOT USED
    MMCN_MENU_BTNCLICK      = 0x800D,
    MMCN_MINIMIZED          = 0x800E,
    MMCN_PASTE              = 0x800F,
    MMCN_PROPERTY_CHANGE    = 0x8010,
    MMCN_QUERY_PASTE        = 0x8011,
    MMCN_REFRESH            = 0x8012,
    MMCN_REMOVE_CHILDREN    = 0x8013,
    MMCN_RENAME             = 0x8014,
    MMCN_SELECT             = 0x8015,
    MMCN_SHOW               = 0x8016, 
    MMCN_VIEW_CHANGE        = 0x8017,
    MMCN_SNAPINHELP         = 0x8018,
    MMCN_CONTEXTHELP        = 0x8019,
    MMCN_INITOCX            = 0x801A,   
    MMCN_FILTER_CHANGE      = 0x801B,
    MMCN_GET_FILTER_MENU    = 0x801C,
    MMCN_FILTER_OPERATOR    = 0x801D,
    
} MMC_NOTIFY_TYPE;

typedef enum _DATA_OBJECT_TYPES
{
    CCT_SCOPE            = 0x8000, // Data object while for scope pane context
    CCT_RESULT           = 0x8001, // Data object while for result pane context
    CCT_SNAPIN_MANAGER   = 0x8002, // Data object while for snap-in manager context
    CCT_UNINITIALIZED    = 0xFFFF, // Data object has an invalid type

} DATA_OBJECT_TYPES;


//New window option(s)
 
const unsigned long MMC_NW_OPTION_NONE          = 0x0000;

// No scope pane
const unsigned long MMC_NW_OPTION_NOSCOPEPANE   = 0x0001;

// No standard toolbars
const unsigned long MMC_NW_OPTION_NOTOOLBARS    = 0x0002;

// Use short window title                                          
const unsigned long MMC_NW_OPTION_SHORTTITLE    = 0x0004;

// Snap-in provides window title
const unsigned long MMC_NW_OPTION_CUSTOMTITLE   = 0x0008;

// Do not save view to console doc file
const unsigned long MMC_NW_OPTION_NOPERSIST     = 0x0010;


///////////////////////////////////////////////////////////////////////////////
// Common Console clipboard formats
//

// Clipboard format for node type guid
const wchar_t* CCF_NODETYPE = L"CCF_NODETYPE"; 

// Clipboard format for string version of node type guid
const wchar_t* CCF_SZNODETYPE = L"CCF_SZNODETYPE";

// Clipboard format for name displayed in scope pane
const wchar_t* CCF_DISPLAY_NAME = L"CCF_DISPLAY_NAME";

// Clipboard format for the snapin's class id.
const wchar_t* CCF_SNAPIN_CLASSID = L"CCF_SNAPIN_CLASSID";

// Clipboard format for window title (for window data object)
const wchar_t* CCF_WINDOW_TITLE = L"CCF_WINDOW_TITLE";

// This is the MMC supplied Multi-select data object.
const wchar_t* CCF_MMC_MULTISELECT_DATAOBJECT = L"CCF_MMC_MULTISELECT_DATAOBJECT";

// Clipboard format for the snapins multi selected dataobjects.
// If there are N snapins whose objects are selected in the result
// pane, these N dataobjects will be passed in a GloballAlloced
// memory. The first DWORD contains the number of snapins, this will
// be followed by N ptrs to the DataObjects.
typedef struct _SMMCDataObjects
{
    DWORD           count;
    LPDATAOBJECT    lpDataObject[1];
    
} SMMCDataObjects;
const wchar_t* CCF_MULTI_SELECT_SNAPINS = L"CCF_MULTI_SELECT_SNAPINS";

// Clipboard format for the array of GUIDs which constitutes the object 
// types of all the currently selected result items put by the snapin.
typedef struct _SMMCObjectTypes
{
    DWORD   count;
    GUID    guid[1];
    
} SMMCObjectTypes;

const wchar_t* CCF_OBJECT_TYPES_IN_MULTI_SELECT = L"CCF_OBJECT_TYPES_IN_MULTI_SELECT";



///////////////////////////////////////////////////////////////////////////////
// APIs exported in mmc.lib
//
cpp_quote("STDAPI MMCPropertyChangeNotify(long lNotifyHandle, long param);")
cpp_quote("STDAPI MMCFreeNotifyHandle(long lNotifyHandle);")
cpp_quote("STDAPI MMCPropPageCallback(void* vpsp);")
cpp_quote("EXTERN_C const CLSID CLSID_NodeManager;")


///////////////////////////////////////////////////////////////////////////////
// Special dataobjects
//
cpp_quote("#define DOBJ_NULL (LPDATAOBJECT)0 ")
cpp_quote("#define DOBJ_CUSTOMOCX (LPDATAOBJECT)-1 ")
cpp_quote("#define DOBJ_CUSTOMWEB (LPDATAOBJECT)-2 ")

///////////////////////////////////////////////////////////////////////////////
// Macros
//
cpp_quote("#define IS_SPECIAL_DATAOBJECT(d) ((int)(d) >= -10 && (int)(d) <= 0)")
cpp_quote("#define IS_SPECIAL_COOKIE(c) ((c) >= -10 && (c) <= -1)")

///////////////////////////////////////////////////////////////////////////////
//  Interfaces
//
    [
        object,
        uuid(955AB28A-5218-11D0-A985-00C04FD8D565),
        helpstring("IComponentData Interface"),
        pointer_default(unique)
    ]
    interface IComponentData : IUnknown
    {
        [helpstring("Snap-in entry point. Can QI for IConsole & IConsoleNameSpace")]
        HRESULT Initialize([in] LPUNKNOWN pUnknown);

        [helpstring("Create a Componet for this ComponetData")]
        HRESULT CreateComponent([out] LPCOMPONENT* ppComponent);

        [helpstring("User actions")]
        HRESULT Notify([in] LPDATAOBJECT lpDataObject, [in] MMC_NOTIFY_TYPE event, 
                       [in] long arg, [in] long param);

        [helpstring("Release cookies associated with the children of a specific node")]
        HRESULT Destroy();

        [helpstring("Returns a data object which may be used to retrieve the context information for the specified cookie")]
        HRESULT QueryDataObject([in] long cookie, [in] DATA_OBJECT_TYPES type,
                                [out] LPDATAOBJECT* ppDataObject);

        [helpstring("Get display info for the name space item")]
        HRESULT GetDisplayInfo([in,out] SCOPEDATAITEM* pScopeDataItem);

        [helpstring("The snap-in's compare function for two data objects")]
        HRESULT CompareObjects([in] LPDATAOBJECT lpDataObjectA, [in] LPDATAOBJECT lpDataObjectB);
    };
    

    [
        object,
        uuid(43136EB2-D36C-11CF-ADBC-00AA00A80033),
        helpstring("IComponent Interface"),
        pointer_default(unique)
    ]
    interface IComponent : IUnknown
    {
        [helpstring("Snap-in entry point")]
        HRESULT Initialize([in] LPCONSOLE lpConsole);
        
        [helpstring("User actions")]
        HRESULT Notify([in] LPDATAOBJECT lpDataObject, [in] MMC_NOTIFY_TYPE event, 
                       [in] long arg, [in] long param);
                       
        [helpstring("Release cookies associated with the children of a specific node")]
        HRESULT Destroy([in] long cookie);

        [helpstring("Returns a data object which may be used to retrieve the context information for the specified cookie")]
        HRESULT QueryDataObject([in] long cookie, [in] DATA_OBJECT_TYPES type,
                                [out] LPDATAOBJECT* ppDataObject);
                        
        [helpstring("Returns the result view type for the specified cookie")]
        HRESULT GetResultViewType([in] long cookie, [out] LPOLESTR* ppViewType, 
                                  [out] long* pViewOptions);

        [helpstring("Get display info for the result item")]
        HRESULT GetDisplayInfo([in,out] RESULTDATAITEM*  pResultDataItem);

        [helpstring("The snap-in's compare function for two data objects")]
        HRESULT CompareObjects([in] LPDATAOBJECT lpDataObjectA, [in] LPDATAOBJECT lpDataObjectB);
    };


    [
        object,
        uuid(E8315A52-7A1A-11D0-A2D2-00C04FD909DD),
        helpstring("Compare interface for sorting result items"),
        pointer_default(unique)
    ]
    interface IResultDataCompare : IUnknown
    {
        [helpstring("Compare two cookies")]
        HRESULT Compare([in] long lUserParam, 
            [in] long cookieA, [in] long cookieB, [in, out] int* pnResult);
    }


    [
        object,
        uuid(9CB396D8-EA83-11d0-AEF1-00C04FB6DD2C),
        helpstring("Interface for owner data result pane list"),
        pointer_default(unique)
    ]
    interface IResultOwnerData : IUnknown
    {
        [helpstring("Find result item that matches string")]
        HRESULT FindItem([in] LPRESULTFINDINFO pFindInfo, [out] int* pnFoundIndex);
        
        [helpstring("Hint to cache result item data")]
        HRESULT CacheHint ([in] int nStartIndex, [in] int nEndIndex);
        
        [helpstring("Sort result items")]
        HRESULT SortItems([in] int nColumn, [in] DWORD dwSortOptions, [in] long lUserParam); 
    }


    [
        object,
        uuid(43136EB1-D36C-11CF-ADBC-00AA00A80033),
        helpstring("IConsole Interface"),
        pointer_default(unique)
    ]
    interface IConsole : IUnknown
    {
        [helpstring("Sets IConsoles header interface")]
        HRESULT SetHeader([in] LPHEADERCTRL pHeader);

        [helpstring("Sets IConsoles toolbar interface")]
        HRESULT SetToolbar([in] LPTOOLBAR pToolbar);

        [helpstring("Queries IConsoles user provided IUnknown")]
        HRESULT QueryResultView([out] LPUNKNOWN* pUnknown);

        [helpstring("Queries the IConsole provided image list for the scope pane.")]
        HRESULT QueryScopeImageList([out] LPIMAGELIST* ppImageList);

        [helpstring("Queries the IConsole provided image list for the result pane.")]
        HRESULT QueryResultImageList([out] LPIMAGELIST* ppImageList);

        [helpstring("Generates a notification to update view(s) because of content change")]
        HRESULT UpdateAllViews([in] LPDATAOBJECT lpDataObject, 
                               [in] long data, 
                               [in] long hint);
        
        [helpstring("Displays a message box")]
        HRESULT MessageBox([in] LPCWSTR lpszText, [in] LPCWSTR lpszTitle,
                           [in] UINT fuStyle, [out] int* piRetval);

        [helpstring("Query for the IConsoleVerb.")]
        HRESULT QueryConsoleVerb([out] LPCONSOLEVERB * ppConsoleVerb);
        
        [helpstring("Selects the given scope item.")]
        HRESULT SelectScopeItem([in] HSCOPEITEM hScopeItem);
        
        [helpstring("Returns handle to the main frame window.")]
        HRESULT GetMainWindow([out] HWND* phwnd);
        
        [helpstring("Create a new window rooted at the scope item specified by hScopeItem.")]
        HRESULT NewWindow([in] HSCOPEITEM hScopeItem, [in] unsigned long lOptions);

    };



    [
        object,
        uuid(43136EB3-D36C-11CF-ADBC-00AA00A80033),
        helpstring("INodeInit Interface"),
        pointer_default(unique)
    ]
    interface IHeaderCtrl : IUnknown
    {
        const int AUTO_WIDTH = -1;  // Column width is determined by the string length + padding

        [helpstring("Add a column to a Default Result view")]
        HRESULT InsertColumn([in] int nCol, [in,] LPCWSTR title, [in] int nFormat, [in] int nWidth);

        [helpstring("Remove a column to a Default Result view")]
        HRESULT DeleteColumn([in] int nCol);

        [helpstring("Set a columns text")]
        HRESULT SetColumnText([in] int nCol, [in] LPCWSTR title);

        [helpstring("Gets a columns text")]
        HRESULT GetColumnText([in] int nCol, [out] LPOLESTR* pText);

        [helpstring("Set a columns width")]
        HRESULT SetColumnWidth([in] int nCol, [in] int nWidth);

        [helpstring("Gets a columns width")]
        HRESULT GetColumnWidth([in] int nCol, [out] int* pWidth);
    };

enum
{
///////////////////////////////////////////////////////////////////////////////
// The following bits in insertion point / submenu IDs are handled specially:
//
// CCM_INSERTIONPOINTID_MASK_SPECIAL:
//   Insertion points and submenus whose IDs contain any bit in
//   CCM_INSERTIONPOINTID_MASK_SPECIAL have special behavior.  Snap-Ins may use
//   the other bits as they see fit.
// CCM_INSERTIONPOINTID_MASK_SHARED:
//   Insertion points and submenus whose IDs contain CCM_INSERTIONPOINTID_MASK_SHARED
//   are shared between the creator of the context menu, the primary extension and
//   the third-party extension.  Any of these entities adding items to a shared
//   insertion point or submenu, add them to the same insertion point or submenu.
//   Only IContextMenuProvider may create insertion points or submenus with this bit
//   set, unless CCM_INSERTIONPOINTID_MASK_CREATE_PRIMARY is also set, in which case
//   only the primary extension may create them.
// CCM_INSERTIONPOINT_CREATE_PRIMARY:
//   Only the system may add insertion points or submenus for which CCM_INSERTIONPOINT_SHARED
//   is set and this bit is not set.  Only the primary extension may add insertion points
//   or submenus for which both bits are set.  This prevents insertion point ID conflicts
//   between insertion points and submenus created by IContextMenuProvider and those
//   created by the primary extension.
// CCM_INSERTIONPOINTID_MASK_ADD_PRIMARY:
//   If CCM_INSERTIONPOINT_SHARED is set and this bit is not set, then
//   the primary extension may not add to this insertion point or submenu.
// CCM_INSERTIONPOINTID_MASK_ADD_3RDPARTY:
//   If CCM_INSERTIONPOINT_SHARED is set and this bit is not set, then
//   the third-party extensions may not add to this insertion point or submenu.
// CCM_INSERTIONPOINTID_MASK_RESERVED:
//   Insertion points and submenus may not be added with any of these bits set.
// CCM_INSERTIONPOINTID_MASK_FLAGINDEX:
//   This mask extracts the the index field from system insertion point IDs.
//   The index gives the bit position of the associated insertion allowed flag.
   
    CCM_INSERTIONPOINTID_MASK_SPECIAL        = 0xFFFF0000,
    CCM_INSERTIONPOINTID_MASK_SHARED         = 0x80000000,
    CCM_INSERTIONPOINTID_MASK_CREATE_PRIMARY = 0x40000000,
    CCM_INSERTIONPOINTID_MASK_ADD_PRIMARY    = 0x20000000,
    CCM_INSERTIONPOINTID_MASK_ADD_3RDPARTY   = 0x10000000,
    CCM_INSERTIONPOINTID_MASK_RESERVED       = 0x0FFF0000,
    CCM_INSERTIONPOINTID_MASK_FLAGINDEX      = 0x0000001F,

///////////////////////////////////////////////////////////////////////////////
// Use these InsertionPointIDs to add items at the predefined insertion points:
//
// 0
//   This is interpreted the same as CCM_INSERTIONPOINTID_ROOT_MENU (see below).
// CCM_INSERTIONPOINTID_PRIMARY_TOP:
//   The primary extension may use this insertion point to add items to the top of
//   the main context menu.
// CCM_INSERTIONPOINTID_PRIMARY_NEW:
//   The primary extension may use this insertion point to add items to the top of
//   the Create New submenu.
// CCM_INSERTIONPOINTID_PRIMARY_TASK:
//   The primary extension may use this insertion point to add items to the top of
//   the Task submenu.
// CCM_INSERTIONPOINTID_3RDPARTY_NEW:
//   Third-party extensions may use this insertion point to add items to the bottom of
//   the Create New submenu.
// CCM_INSERTIONPOINTID_3RDPARTY_TASK:
//   Third-party extensions may use this insertion point to add items to the bottom of
//   the Task submenu.
// CCM_INSERTIONPOINTID_ROOT_MENU:
//   IContextMenuProvider may use this insertion point to add items to the root menu.
//   Neither primary extensions nor third-party extension may add items to the root
//   menu except through insertion points added by IContextMenuProvider.
//
    CCM_INSERTIONPOINTID_PRIMARY_TOP   = 0xA0000000, // SHARED and ADD_PRIMARY
    CCM_INSERTIONPOINTID_PRIMARY_NEW   = 0xA0000001, // SHARED and ADD_PRIMARY
    CCM_INSERTIONPOINTID_PRIMARY_TASK  = 0xA0000002, // SHARED and ADD_PRIMARY
    CCM_INSERTIONPOINTID_PRIMARY_VIEW  = 0xA0000003, // SHARED and ADD_PRIMARY
    CCM_INSERTIONPOINTID_3RDPARTY_NEW  = 0x90000001, // SHARED and ADD_3RDPARTY
    CCM_INSERTIONPOINTID_3RDPARTY_TASK = 0x90000002, // SHARED and ADD_3RDPARTY
    CCM_INSERTIONPOINTID_ROOT_MENU     = 0x80000000  // SHARED
};

//
// Macro to derive an insertion allowed flag from an system insertion point ID
//
#define INSERTALLOWED_FLAG(insertionID) \
         (1L << (insertionID & CCM_INSERTIONPOINTID_MASK_FLAGINDEX)) 
enum
{
/////////////////////////////////////////////////////////////////////////////////////  
// These flags give permission to insert menu items at the CCM_INSERTIONPOINTID_xxx
// insertion points define above. The bit position of each flag is derived from the
// index portion of the corresponding insertion point ID. They are passed to the
// snap-in's AddMenuItems method.  

   CCM_INSERTIONALLOWED_TOP  = INSERTALLOWED_FLAG(CCM_INSERTIONPOINTID_PRIMARY_TOP),
   CCM_INSERTIONALLOWED_NEW  = INSERTALLOWED_FLAG(CCM_INSERTIONPOINTID_PRIMARY_NEW),
   CCM_INSERTIONALLOWED_TASK = INSERTALLOWED_FLAG(CCM_INSERTIONPOINTID_PRIMARY_TASK),
   CCM_INSERTIONALLOWED_VIEW = INSERTALLOWED_FLAG(CCM_INSERTIONPOINTID_PRIMARY_VIEW)
};


enum
{
///////////////////////////////////////////////////////////////////////////////
// The following bits in menu command IDs are handled specially:
//
// CCM_COMMANDID_MASK_RESERVED:
//   Items other than insertion points and submenus may not be added with any of
//   these bits set.
// 
    CCM_COMMANDID_MASK_RESERVED       = 0xFFFF0000
};

enum
{
///////////////////////////////////////////////////////////////////////////////
// The following flags may be passed via AddMenuItem parameter fSpecialFlags:
//
// CCM_SPECIAL_SEPARATOR
//   Ignore all other parameters except lInsertionPointID.  Add a separator to the
//   end of the menu or the specified insertion point, except that
//   CCM_SPECIAL_SEPARATOR will never add a separator as the first or last item
//   in a menu/submenu, and if two or more consecutive CCM_SPECIAL_SEPARATORs are added,
//   only one appears in the menu.  Only IContextMenuProvider is permitted to add
//   separators, either special or otherwise, to menus created by IContextMenuProvider.
//
    CCM_SPECIAL_SEPARATOR         = 0x0001,
//
// CCM_SPECIAL_SUBMENU
//   If this submenu is empty, then it will be grayed and disabled.
//   This is only valid for MF_POPUP items.
//
    CCM_SPECIAL_SUBMENU           = 0x0002,
//
// CCM_SPECIAL_DEFAULT_ITEM
//   This should be the default menu item.  If more than one menu item specifies this flag,
//   the last one in each submenu takes precedence.
//
    CCM_SPECIAL_DEFAULT_ITEM      = 0x0004,
//
// CCM_SPECIAL_INSERTION_POINT
//   Ignore all other parameters except lCommandID and lInsertionPointID.  This creates
//   a new "insertion point" at the end of the insertion point or submenu identified by
//   lInsertionPointID (0 is the end of the main menu).  Subsequent calls may use
//   the lCommandID from this call as their lInsertionPointID, and insert their own
//   menu items, submenus or insertion points at this point in this menu.
//
    CCM_SPECIAL_INSERTION_POINT   = 0x0008,
//
// CCM_SPECIAL_TESTONLY
//   Perform the normal validation of the menu item parameters and return the appropriate
//   result code, but do not actually add the menu item. 
//
    CCM_SPECIAL_TESTONLY          = 0x0010     
};


    [
        object,
        uuid(43136EB7-D36C-11CF-ADBC-00AA00A80033),
        helpstring("IContextMenuCallback Interface"),
        pointer_default(unique)
    ]
    interface IContextMenuCallback : IUnknown
    {
        // returns S_OK if the item was added
        // returns E_INVALIDARG if given a NULL pointer
        // returns E_INVALIDARG if an item already exists with this lCommandID
        // returns E_INVALIDARG if insertion point ID could not be found
        // returns E_INVALIDARG if command ID or insertion point ID is invalid
        // returns E_INVALIDARG if fFlags contains MF_OWNERDRAW or MF_BITMAP
        // returns E_INVALIDARG if an extension attempts to add an item where
        //   fFlags contains MF_SEPARATOR or fSpecialFlags contains CCM_SPECIAL_SEPARATOR
        //   except in submenus created by extensions
        // otherwise an unexpected error occurred
        [helpstring("Adds one item to context menu")]
        HRESULT AddItem([in] CONTEXTMENUITEM* pItem);
    };



    [
        object,
        uuid(43136EB6-D36C-11CF-ADBC-00AA00A80033),
        object,
        helpstring("IContextMenuProvider Interface"),
        pointer_default(unique)
    ]
    //
    // Note that this derives from IContextMenuCallback
    //
    interface IContextMenuProvider : IContextMenuCallback
    {
        // Methods
        // returns S_OK unless an unexpected error occurs
        [helpstring("Clear context menu")]
        HRESULT EmptyMenuList();

        // returns S_OK if successful
        // returns E_INVALIDARG on NULL parameter
        // passes through return code from IExtendContextMenu::AddMenuItems
        //   or from CoCreateInstance
        // otherwise an unexpected error occurred
        [helpstring("Allow the primary extension to add to bottom of context menu")]
        HRESULT AddPrimaryExtensionItems([in] LPUNKNOWN piExtension, [in] LPDATAOBJECT piDataObject);

        // returns S_OK if successful
        // returns E_INVALIDARG on NULL parameter
        // returns S_FALSE if context menu has already been extended
        // passes through return code from IExtendContextMenu::AddMenuItems
        //   or from CLSIDToString or CoCreateInstance
        // otherwise an unexpected error occurred
        [helpstring("Allow third-party extensions to add to bottom of context menu")]
        HRESULT AddThirdPartyExtensionItems([in] LPDATAOBJECT piDataObject);

        // returns S_OK unless an unexpected error occurs
        [helpstring("Display context menu")]
        HRESULT ShowContextMenu([in] HWND hwndParent, [in] long xPos, [in] long yPos, [out,retval] long* plSelected);
    };


    [
        object,
        uuid(4F3B7A4F-CFAC-11CF-B8E3-00C04FD8D5B0),
        helpstring("IExtendContextMenu Interface"),
        pointer_default(unique)
    ]
    interface IExtendContextMenu : IUnknown
    {
        [helpstring("Extension may add context menu items via callback interface")]
        HRESULT AddMenuItems([in] LPDATAOBJECT piDataObject,
                             [in] LPCONTEXTMENUCALLBACK piCallback,
                             [in,out] long *pInsertionAllowed);

        [helpstring("Extension context menu item was selected")]
        HRESULT Command([in] long lCommandID, [in] LPDATAOBJECT piDataObject);
    };

    [
        object,
        uuid(43136EB8-D36C-11CF-ADBC-00AA00A80033),
        helpstring("IImageList Interface"),
        pointer_default(unique)
    ]
    interface IImageList : IUnknown
    {
        [helpstring("Sets an Icon in the image list, creates it if it is not there.")]
        HRESULT ImageListSetIcon([in] long* pIcon, [in] long nLoc);

        [helpstring("Sets a strip in the image list, starting at nLoc using a pair of bitmaps.")]
        HRESULT ImageListSetStrip([in] long* pBMapSm,
            [in] long* pBMapLg,[in] long nStartLoc, [in] COLORREF cMask);
    };

    

    [
        object,
        uuid(31DA5FA0-E0EB-11cf-9F21-00AA003CA9F6),
        helpstring("IResultData Interface"),
        pointer_default(unique)
    ]
    interface IResultData : IUnknown
    {
        [helpstring("Allows the snap-in to insert a single item.")]
        HRESULT InsertItem([in,out] LPRESULTDATAITEM item);

        [helpstring("Allows the snap-in to delete a single item.")]
        HRESULT DeleteItem([in] HRESULTITEM itemID, [in] int nCol);

        [helpstring("Allows the snap-in to find an item/subitem based on its user inserted lParam.")]
        HRESULT FindItemByLParam([in] LPARAM lParam, [out] HRESULTITEM *pItemID);

        [helpstring("Allows the snap-in to delete all the items.")]
        HRESULT DeleteAllRsltItems();

        [helpstring("Allows the snap-in to set a single item.")]
        HRESULT SetItem([in] LPRESULTDATAITEM item);

        [helpstring("Allows the snap-in to get a single item.")]
        HRESULT GetItem([in,out] LPRESULTDATAITEM item);

        [helpstring("Returns the lParam of the first item, which matches the given state.")]
        HRESULT GetNextItem([in,out] LPRESULTDATAITEM item);
      
        [helpstring("Allows the snap-in to modify the state of an item.")]
        HRESULT ModifyItemState([in] int nIndex, [in] HRESULTITEM itemID,
                                [in] UINT uAdd, [in] UINT uRemove);

        [helpstring("Allows the snap-in to set the result view style.")]
        HRESULT ModifyViewStyle([in] MMC_RESULT_VIEW_STYLE add, 
                             [in] MMC_RESULT_VIEW_STYLE remove);

        [helpstring("Allows the snap-in to set the result view mode.")]
        HRESULT SetViewMode([in] long lViewMode);

        [helpstring("Allows the snap-in to get the result view mode.")]
        HRESULT GetViewMode([out] long* lViewMode);

        [helpstring("Allows the snap-in to update a single item.")]
        HRESULT UpdateItem([in] HRESULTITEM itemID);

        [helpstring("Sort all items in result pane")]
        HRESULT Sort([in] int nColumn, [in] DWORD dwSortOptions, [in] long lUserParam);

        [helpstring("Set the description bar text for the result view")]
        HRESULT SetDescBarText([in] LPOLESTR DescText);

        [helpstring("Set number of items in result pane list")]
        HRESULT SetItemCount([in] int nItemCount, [in] DWORD dwOptions);
        
    };


    [
        object,
        uuid(9757abb8-1b32-11d1-a7ce-00c04fd8d565),
        helpstring("IQuickFilter Interface"),
        pointer_default(unique)
    ]
    interface IQuickFilter : IUnknown
    {
        [helpstring("Sets the time out for the quick filter")]
        HRESULT SetChangeTimeOut([in] unsigned long uTimeout);
        
        [helpstring("Sets the quick filter")]
        HRESULT SetQuickFilter([in] UINT nColumn, [in] LPFILTERDATA);
        
        [helpstring("Gets the quick filter")]
        HRESULT GetQuickFilter([in] UINT nColumn, [out] LPFILTERDATA);
    };
    


    [
        object,
        uuid(BEDEB620-F24D-11cf-8AFC-00AA003CA9F6),
        helpstring("IConsoleNameSpace Interface"),
        pointer_default(unique)
    ]
    interface IConsoleNameSpace : IUnknown
    {
        import "oaidl.idl";
        [helpstring("Allows the snap-in to insert a single item into the scope view.")]
        HRESULT InsertItem([in,out] LPSCOPEDATAITEM  item);

        [helpstring("Allows the snap-in to delete a single item from the scope view.")]
        HRESULT DeleteItem([in] HSCOPEITEM hItem, [in] long fDeleteThis);

        [helpstring("Allows the snap-in to set a single scope view item.")]
        HRESULT SetItem([in] LPSCOPEDATAITEM item);

        [helpstring("Allows the snap-in to get a single scope view item.")]
        HRESULT GetItem([in,out] LPSCOPEDATAITEM item);
        
        [helpstring("The handle of the child item if successful, otherwise NULL.")]
        HRESULT GetChildItem([in] HSCOPEITEM item, [out] HSCOPEITEM* pItemChild,
                             [out] long* plCookie);
        
        [helpstring("The handle of the next item if successful, otherwise NULL.")]
        HRESULT GetNextItem([in] HSCOPEITEM item, [out] HSCOPEITEM* pItemNext,
                            [out] long* plCookie);
                            
        [helpstring("The handle of the parent item if successful, otherwise NULL.")]
        HRESULT GetParentItem([in] HSCOPEITEM item, [out] HSCOPEITEM* pItemParent,
                              [out] long* plCookie);
    };

struct _PSP;
typedef struct _PSP * HPROPSHEETPAGE;

    [
        local,
        object,
        uuid(85DE64DD-EF21-11cf-A285-00C04FD8DBE6),
        helpstring("IPropertySheetCallback Interface"),
        pointer_default(unique)
    ]
    interface IPropertySheetCallback : IUnknown
    {

        [helpstring("Snap-in uses this to add a page to a property sheet")]
        HRESULT AddPage([in] HPROPSHEETPAGE hPage);

        [helpstring("Snap-in uses this to remove a page from a property sheet")]
        HRESULT RemovePage([in] HPROPSHEETPAGE  hPage);
    };

    [
        object,
        uuid(85DE64DE-EF21-11cf-A285-00C04FD8DBE6),
        helpstring("IPropertySheetProvider Interface"),
        pointer_default(unique)
    ]
    interface IPropertySheetProvider : IUnknown
    {
        [helpstring("Creates a property sheet frame")]
        HRESULT CreatePropertySheet([in] LPCWSTR title, [in] boolean type, 
                                    [in] long cookie, [in] LPDATAOBJECT pIDataObjectm,
                                    [in] DWORD dwOptions);

        [helpstring("Determine if the property sheet exist")]
        HRESULT FindPropertySheet([in] long cookie, [in] LPCOMPONENT lpComponent, [in] LPDATAOBJECT lpDataObject);

        [helpstring("Collects the pages from the primary snap-in")]
        HRESULT AddPrimaryPages(LPUNKNOWN lpUnknown, BOOL bCreateHandle, HWND hNotifyWindow, BOOL bScopePane);

        [helpstring("Collects the pages from the extension snap-in(s)")]
        HRESULT AddExtensionPages();

        [helpstring("Shows a property sheet frame parented to the HWND passed in")]
        HRESULT Show([in] long window, [in] int page);
    };

    [
        object,
        uuid(85DE64DC-EF21-11cf-A285-00C04FD8DBE6),
        helpstring("IExtendPropertySheet Interface"),
        pointer_default(unique)
    ]
    interface IExtendPropertySheet : IUnknown
    {
        [helpstring("Interface implemented by the snap-in to add pages to a sheet")]
        // handle - This handle must be saved in the property page object 
        //          to notify the parent of changes in property using API 
        //          MMCPropertyChangeNotify. The API MMCFreeNotifyHandle
        //          should be called just before the property page is
        //          destroyed to delete the handle.
        HRESULT CreatePropertyPages([in] LPPROPERTYSHEETCALLBACK lpProvider,
                                    [in] long handle, 
                                    [in] LPDATAOBJECT lpIDataObject);

        [helpstring("Interface implemented by the snap-in to determine if this object needs pages")]
        HRESULT QueryPagesFor([in] LPDATAOBJECT lpDataObject);
    };



    [
        object,
        uuid(69FB811E-6C1C-11D0-A2CB-00C04FD909DD),
        helpstring("Control bar to hold toolbar and other controls"),
        pointer_default(unique)
    ]
    interface IControlbar : IUnknown
    {
        [helpstring("Create and return the control requested")]
        HRESULT Create([in] MMC_CONTROL_TYPE nType, 
                       [in] LPEXTENDCONTROLBAR pExtendControlbar,
                       [out] LPUNKNOWN* ppUnknown);

        [helpstring("Associated the control to the control bar")]
        HRESULT Attach([in] MMC_CONTROL_TYPE nType, [in] LPUNKNOWN  lpUnknown);

        [helpstring("Break the association between the control and the control bar")]
        HRESULT Detach([in] LPUNKNOWN lpUnknown);
    };

    [
        object,
        uuid(49506520-6F40-11D0-A98B-00C04FD8D565),
        helpstring("IExtendControlbar Interface"),
        pointer_default(unique)
    ]
    interface IExtendControlbar : IUnknown
    {
        [helpstring("Extension may add toolbars via callback interface")]
        HRESULT SetControlbar([in] LPCONTROLBAR pControlbar);
        
        [helpstring("User actions")]
        HRESULT ControlbarNotify([in] MMC_NOTIFY_TYPE event, 
                                 [in] long arg, [in] long param);
    };


    [
        object,
        uuid(43136EB9-D36C-11CF-ADBC-00AA00A80033),
        pointer_default(unique)
    ]
    interface IToolbar : IUnknown
    {
        [helpstring("Add and image to the toolbar")]
        HRESULT AddBitmap([in] int nImages, [in] HBITMAP hbmp, [in] int cxSize, [in] int cySize, [in] COLORREF crMask );
    
        [helpstring("Add an array of buttons to the toolbar")]
        HRESULT AddButtons([in] int nButtons, [in] LPMMCBUTTON lpButtons);

        [helpstring("Add a single button to the toolbar at position nIndex")]
        HRESULT InsertButton([in] int nIndex, [in] LPMMCBUTTON lpButton); 

        [helpstring("Remove a button at the index")]
        HRESULT DeleteButton([in] int nIndex);
    
        [helpstring("Get an attribute of a button")]
        HRESULT GetButtonState([in] int idCommand, [in] MMC_BUTTON_STATE nState, [out] BOOL* pState);

        [helpstring("Set an attribute of a button")]
        HRESULT SetButtonState([in] int idCommand, [in] MMC_BUTTON_STATE nState, [in] BOOL bState);
    };


    [
        object,
        uuid(E49F7A60-74AF-11D0-A286-00C04FD8FE93),
        pointer_default(unique)
    ]
    interface IConsoleVerb : IUnknown
    {
        [helpstring("Get verb state")]
        HRESULT GetVerbState([in] MMC_CONSOLE_VERB eCmdID, [in] MMC_BUTTON_STATE nState, [out] BOOL* pState);

        [helpstring("Set verb state")]
        HRESULT SetVerbState([in] MMC_CONSOLE_VERB eCmdID, [in] MMC_BUTTON_STATE nState, [in] BOOL bState);
                          
        [helpstring("Set default verb")]
        HRESULT SetDefaultVerb([in] MMC_CONSOLE_VERB eCmdID);
        
        [helpstring("Get default verb")]
        HRESULT GetDefaultVerb([out] MMC_CONSOLE_VERB* peCmdID);
    };


    [
        object,
        uuid(1245208C-A151-11D0-A7D7-00C04FD909DD),
        pointer_default(unique)
    ]
    interface ISnapinAbout : IUnknown
    {
        [helpstring("Text for the snap-in description box")]
        HRESULT GetSnapinDescription([  out] LPOLESTR* lpDescription);

        [helpstring("Provider name")]
        HRESULT GetProvider([out] LPOLESTR* lpName);

        [helpstring("Version number for the snap-in")]
        HRESULT GetSnapinVersion([out] LPOLESTR* lpVersion);

        [helpstring("Main icon for about box")]
        HRESULT GetSnapinImage([out] HICON* hAppIcon);

        [helpstring("Static folder images for scope and result panes")]
        HRESULT GetStaticFolderImage([out] HBITMAP* hSmallImage, 
                                     [out] HBITMAP* hSmallImageOpen, 
                                     [out] HBITMAP* hLargeImage, 
                                     [out] COLORREF* cMask);
    };


    [
        object,
        uuid(951ED750-D080-11d0-B197-000000000000),
        pointer_default(unique)
    ]
    interface IMenuButton : IUnknown
    {
        [helpstring("Adds a button")]
        HRESULT AddButton([in] int idCommand,[in] LPOLESTR lpButtonText,
                                             [in] LPOLESTR lpTooltipText);

        [helpstring("Set an attributes of a button")]
        HRESULT SetButton([in] int idCommand,[in] LPOLESTR lpButtonText,
                                             [in] LPOLESTR lpTooltipText);

        [helpstring("Set the state of a button")]
        HRESULT SetButtonState([in] int idCommand, 
                               [in] MMC_BUTTON_STATE nState, 
                               [in] BOOL bState);
    };



    [
        object,
        uuid(A6B15ACE-DF59-11D0-A7DD-00C04FD909DD),
        pointer_default(unique)
    ]
    interface ISnapinHelp : IUnknown
    {
        [helpstring("Get the compiled help file (.chm) from a snap-in to merge")]
        HRESULT GetHelpTopic([out] LPOLESTR* lpCompiledHelpFile);
    }
