========================================
func_machinegun (Стационарный пулемет)
========================================
"Model" - путь к модели. Пулемет делается не из брашей, а из модели.
"Rate of fire" - скорострельность - количество выстрелов в минуту.
"ammo"  - количество патронов (максимум 999, а если -1, то бесконечные).
"Damage" - дамаг одной пульки.
"Basis height" - высота точки вращения пулемета (т.е. точки главного контроллера в модели)
"Viewport forward dist", "Viewport up dist" - смещения обзора игрока назад и вверх относительно ствола.


trigger_mp3 (Проигрывание MP3-треков)
========================================
"targetname" - имя 
"message" - путь к mp3-файлу.  (например: sound/music/track01.mp3)

Активируешь - мп3 играет. Играет зацикленно - до тех пор, 
пока не остановишь. Чтобы остановить, надо использовать еще 
одну trigger_mp3, где путь к файлу будет пустым.
Консольная команда stopmp3 - вырубает играющую в данный момент музыку.

scripted_startrush (Rush AI script)
========================================
Это такой новый вид скрипта, который заставляет монстра с боем 
прорываться в нужную точку.

"Targeted monster" - монстр
"Fire after move" - цель, активируемая после того, как монстр 
прибудет в нужную точку. Locus'ом при этом явялется монстр - на 
тот случай, если ты юзаешь локусы.
"Move to this entity"	- энтитя, к которой надо бежать 
(если оставить пустым, то будет бежать к этой scripted_startrush)
"Move type" - тип передвижения - бегом или шагом.
"Area radius" - радиус области вокруг цели, в которую 
надо прибежать (не обязательно бежать именно в точку, 
достаточно в ее окрестность)

Применение - оборона точки и помощи 
союзникам в прорыве куда-либо, до простого разнообразия 
поведения врагов - например, игрок не просто находит в очередном 
коридоре пару скучающих америкосов, а сталкивается с ними 
лицом к лицу в то время, как они тоже куда-то прогуливаются .. :)

rain_settings и rain_modify (Дождь)
========================================
Каждая карта, где может идти дождь, должна в 
единственном экземпляре содержать энтитю rain_settings. 
Ее роль проста - она устанавливает глобальные для этой карты параметры дождя. 
Энтитя должна быть расположена на той высоте, где будут появляються капли. 

Параметров у энтити только два - тип осадков и радиус от игрока. 
Радиус трогать не обязательно - он по умолчанию установлен довольно оптимально. 
Хотя если карта "коридорная" (переулочная), то можно сделать и поменьше.

Для непосредственного включения и выключения дождя используется энтитя rain_modify. 
У нее уже параметров побольше:
Drips per second	- количество капель, появляющихся в секунду. 
Нормальный такой дождь - где-то 2000 капель.
Wind X, Wind Y	- отклонение по ветру. 100, 200 - уже приличный "косой" дождь.
Rand X, Rand Y	- разброс отклонения по ветру для каждой капли. 
Например, если ветер стоит 200, а разброс - 40, то для каждой капли отклонение 
будет варьироваться от 160 до 240.

Еще один параметр - Fading time - т.е. время, за которое дождь приобретет 
указанные настройки. Задается в секундах. Ну сам понимаешь - это для плавного 
включения и выключения дождя. Минута-две вполне подойдет (все-равно, в 
экшен-играх всегда события развиваются быстрее, чем в реале, т.к жанр обязывает :) ).

Можно просто задать постоянный дождь на карте, без включений и выключений - для 
этого не надо указывать rain_modify имя.



Subtitles     (Субтитры)
========================================

Субтитры привязываются к сентенсам через записи в titles.txt. Например, 
сентенсу SC_PHELLO2 будет соответствовать такая запись:

!SC_PHELLO2
{
- Ah, it's good to see you.
}

То есть, имя записи в titles.txt - это восклицательный знак плюс имя сентенса.
Но если просто добавить эту запись в titles.txt, то хоть текст и появится при произнесении этой реплики персонажем, 
но он появится не в специальном месте, отведенном под субтитры, а просто как обычное сообщение, 
выводимое game_text'ом. Чтобы указать, что это сообщение должно выводиться в область 
субтитров, нужно перед ним задать код эффекта:

$effect 3

Эффекты от нуля до двух используются в сообщениях вальве - о них можно прочитать в комментариях вначале titles.txt.
Также через параметр holdtime можно указать время, которое реплика будет держаться на экране:

$holdtime 4

Правда это не значит, что она будет находиться в области субтитров именно четыре 
секунды - это зависит от того, сколько сообщений еще стоит перед ней, и как быстро они прокручиваются.
Используя параметр color, можно менять цвет букв:

$color 255 255 255

(лучше это вставить сразу где-нибудь вначале файла)

Шрифт для всех добавленных элементов худа используется пока все тот-же - Default Text. 
Когда разделаюсь со шрифтами до конца, сделаю возможность писать реплики разным шрифтом.

Никаких рамок и подложек к тексту субтитров я пока делать не стал, но зато 
под буквами есть как-бы тень - это облегчает их чтение на светлом фоне.

При желании можно выдавать любой текст в область субтитров 
через env_message - надо только проставить код эффекта 3.

Консольные переменные, связанные с субтитрами:
subtitles 1 - включить субтитры (по умолчанию включены)
subtitles 0 - выключить субтитры
subt_scrollspd - скорость прокрутки сообщений (по умолчанию 250)
subt_fadespd - время fading'а, т.е. плавного появления/затухания сообщений (по умолчанию 0.2)
subt_mintime, subt_maxtime - если заданы (т.е. отличны от нуля), то определяют минимальное и 
максимальное время нахождения реплики на экране в секундах - накладывают ограничения на 
параметр holdtime (По умолчанию 0 - выключено)

в начале любой субтитровой записи в titles.txt можно поставить 
знак доллара и прописать,  какая запись появится на экране после 
того, как эта исчезнет. Вот например, была у нас одна большая запись: 

#holdtime 20 
!TEST 
{ 
Я 24-хлетний инженер по технической поддержке в компании "Эльбрус". Занимаюсь всякими Sun'овскими станциями в основном, но иногда приходится собирать и обычные персоналки. В общем, работа не очень-то простая, но жить можно. Левелмейкерством заразился год назад, после того как у меня появился доступ в сеть с работы. Первое, что меня вдохновило, так это сайт Matt Sefton'а - Single Player Quake Level Heaven. Там собраны, на мой взгляд, самые лучшие работы. С этого-то всё и началось. 
} 

И эту большую запись мы разбиваем на три - TEST, TEST_a и TEST_b 

#holdtime 7 
!TEST 
{ 
$TEST_a 
Я 24-хлетний инженер по технической поддержке в компании "Эльбрус". Занимаюсь всякими Sun'овскими станциями в основном, но иногда приходится собирать и обычные персоналки. 
} 

TEST_a 
{ 
$TEST_b 
В общем, работа не очень-то простая, но жить можно. Левелмейкерством заразился год назад, после того как у меня появился доступ в Сеть с работы. 
} 

TEST_b 
{ 
Первое, что меня вдохновило, так это сайт Matt Sefton'а - Single Player Quake Level Heaven. Там собраны, на мой взгляд, самые лучшие работы. С этого-то всё и началось. 
} 

то есть, TEST после себя вызывает TEST_a, и та в свою очередь, вызывает TEST_b. 
При желании, так в цепь можно соединять диалоги.



env_grass_sprite (трава)
=================================

Для установки на карте автоматически разбрасываемой травки используется 
точечная энтитя env_grass_sprite. Место, где будет размещена энтитя, имеет 
такое-же значение, как и для rain_settings. Представь что трава изначально 
появляется на той-же высоте, на какой установлена энтитя env_grass_sprite, 
и потом как-бы падает на землю :) То есть, лучше эти энтити ставить где-нибудь 
в небе, чтобы они точно были выше всей земли. 

Назначение полей энтити, вобщем-то, тривиально -

Sprite Name - имя спрайта
Radius - дистанция от игрока, после которой они исчезают (например, 800)
Density - количество спрайтов внутри этого радиуса (например, 200)
Sprite scale - то-же, что и scale в env_sprite (кстати, скаль чуть-чуть варьируется по рандому)
Sprite Orientation - ориентация спрайта. Поэкспериментируй с первыми тремя режимами.

Можно вместо спрайта указать модель - тогда в поле Sprite Orientation надо выбрать четвертый режим "Model".

Необходимо указать имена текстур, на которых этот спрайт может "расти". 
Для этого надо отключить SmartEdit и добавить новые ключи, где имя ключа - это 
имя текстуры (все буквы в нижнем регистре), а значение ключа - любое число. 
Дополнительных ключей (т.е. текстур) максимум может быть восемь. Прмиер ключа:
Key: out_grnd1
Value: 1

Суммарное количество энтитей env_grass_sprite на карте не должно превышать 32.
Сумма всех значений Density для спрайтов не должна превышать 1000, для моделей - 100.


radio_sentence (Радио-сообщения)
=================================

Иконка с радио и соответствующий wav-файл активируются энтитей
radio_sentence.
Все настройки довольно простые:

Wav name - звук
talker's name - имя, которое появится рядом с динамиком на иконке справа 
(Можно прописать прямо, но лучше сослаться в titles.txt - чтобы оно могло быть 
и по-русски, и по-английски. Т.е. если имя записи в titles.txt 
называется "TALKER", то в это поле надо прописать "#TALKER")
Hold time - сколько секунд иконка будет торчать на экране (т.е. сколько длится звук)
Label color - цвет фона иконки. 
Для разных персонажей можно использовать разные цвета.
Transparency - прозрачность фона. Сделал на всякий случай.



Tab-окошко для задач
=================================

Энтитя trigger_goal служит для изменения текста в окошке задач. 
Помимо имени для активации она содержит единственное поле - Goal text. конечно, 
целиком описание в одно поле не уместить, поэтому просто пиши 
тут ссылку в titles.txt.

Как обсуждалось, нажатием TAB игрок может скрыть и показать это окошко 
При смене описания задачи окошко выскакивает на экран. 
Если игрок самостоятельно его не скроет, 
то оно само исчезнет через задаваемый консольной переменной gpanel_hidetime 
промежуток времени (по умолчанию - двадцать секунд). Если-же игрок сам открыл 
окошко, то оно автоматически исчезать не будет.

Можно оставить поле Goal text пустым - тогда при активации эта энтитя просто удалит 
запись о задаче, и нажатие TAB уже не будет включать никакое окошко.
К энтите trigger_goal, соответственно, добавлены еще два поля:

- Goal Title - задает заголовок окна (как обычно, 
можно сунуть ссылку в титлес.тхт)
- TGA Image - путь к TGA картинке

Правила указания путей к картинке такие-же, как и правила их 
задания в текстовых vgui-окнах - можно либо явно 
указать путь (но тогда во всех разрешениях будет использована одна и 
та-же картинка, что не есть гуд), либо вставить в путь символ %d, 
вместо которого потом будет подставлено текущее разрешение. 
Если для текущего разрешения специальной картинки нету, то будет 
загружена картинка для более низкого.
Например, имеем картинки:
texts\320_zavod.tga
texts\640_zavod.tga
texts\1024_zavod.tga
Значит, в поле TGA Image надо прописать:
texts\%d_zavod.tga